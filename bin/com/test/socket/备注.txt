这是一个基于Socket的长连接，是阻塞的，在于这里面的read方法和write（包括println）方法是阻塞的。每个连接请求都会重新创建一个新的线程来处理，从而实现接受多个连接请求。

示例的程序中有两个问题。第一，如果客户端突然停止断开了，那么服务端会抛出一个SocketException（Connection Reset），这是由于客户端或者服务端有一边断了，但是另一边没有断开造成的，调用close方法就不会有这样的问题。

另一个问题就是如果客户端连着，但是服务端被停止了，那么客户端在没有发送消息的情况下，是不会有任何反应的，一旦客户端发送消息，那么客户端自身会抛出一个SocketException（Connection Reset），解释与上面应该是一样的。

这里基本上演示了如何实现一个长连接，说白了，不断开连接的就是一个长连接。显然，这个例子可能没有多少实用价值，问题在于：

客户端无法感知到服务端状态的变化，这个问题需要客户端自己来检测当前服务端的状态，比如说心跳；
多线程的问题，这里一个线程处理一个客户端，如果有很多客户端同时发起连接，会启动很多线程，这个显然也是有问题的。还有就是线程太多，导致上下文切换带来的消耗还是蛮客观的，不过这里略过不讨论。
这些问题下面再讨论，先来看一个非阻塞的长连接。Java中的NIO对非阻塞IO有了较好的支持。